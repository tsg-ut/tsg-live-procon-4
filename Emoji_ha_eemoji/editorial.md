# 解説
まず、`?`が無い場合の容量を高速に計算する方法を考えます。
部分画像は最大でも $\Sigma_{i=0}^10 4^i = 1398101 \approx 10^6 $ 個しかないので、
各画像に対してhash値のようなものを計算して、hash値の種類数を数えることにします。
このとき、画像$X$のhash値を、$X$を田の字に4分割してできる画像を $x_1, \cdots, x_4$ として、
$\mathrm{hash}(X) = f((\mathrm{hash}(x_1),\mathrm{hash}(x_2),\mathrm{hash}(x_3),\mathrm{hash}(x_4)) $ として
計算するとよさそうです。ここで、$f : int * int * int * int \to int $ は、同じ4つ組に対しては同じ整数を返し、
違う4組に対しては違う整数を返すような関数とします。たとえば、C++ではSTLのmapを用いると手軽にfを計算できるでしょう。
また、特別に`.`と`#`だけの画像のhash値をそれぞれ0,1として、$f((0,0,0,0)) = 0, f((1,1,1,1)) = 1 $ としておくと
相似なもののhash値を等しくできることがわかります。このようにすると、再帰的にhash値を計算したあとに
hash値集合の大きさを求めることで、`?`がない場合の容量を高速に計算することができます。

`?`のある場合ですが、各`?`についての`#`,`.`の埋め方を全探索して、一番容量の少ないものを選ぶことを考えます。
ひとつの`?`の値を変えることによりhash値の変わる部分画像はたかだか10個(4分木の深さ)なので、
`?`のない部分画像について最初にまとめてhash値を計算したあと、`?`の部分を適当に埋めて変化する部分だけhash値を計算するようにしてみます。
このとき`?`の埋め方は、`?`の数がたかだか10個なのでたかだか$2^{10}$通り。各`?`を埋める際にhashを再計算しなければならない場所はたかだか
$10 * 10$ 箇所なので、hashの計算回数はたかだか $2^{10} * 10 * 10 \approx 10^5 $ 程度となり、hash計算のための定数倍を考えても十分速く
計算することができます。

注意点として、`#`もしくは`.`だけからなる画像	の容量は1ですが、hash値をmapなどを用いて実装している場合、
答えが2以上しか返らない実装になってしまうことがあります。
